<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Support Cell Test - Background Walls / Pillars</title>
  <style>
    body { font-family: system-ui, sans-serif; background: #1a1a1a; color: #eee; padding: 20px; }
    .test { margin: 10px 0; padding: 10px; border-radius: 6px; cursor: pointer; }
    .test:hover { opacity: 0.8; }
    .pass { background: #1a4a1a; border: 1px solid #2a6a2a; }
    .fail { background: #4a1a1a; border: 1px solid #6a2a2a; }
    .pending { background: #3a3a1a; border: 1px solid #5a5a2a; }
    .running { background: #1a3a4a; border: 1px solid #2a5a6a; }
    canvas { border: 1px solid #444; margin: 10px 0; display: block; }
    pre { background: #222; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 12px; max-height: 200px; overflow-y: auto; }
    h2 { margin-top: 30px; }
    .controls { margin: 10px 0; }
    button { background: #333; color: #eee; border: 1px solid #555; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 8px; }
    button:hover { background: #444; }
    .info { font-size: 12px; opacity: 0.7; margin-top: 5px; }
    .legend { display: flex; gap: 20px; margin: 10px 0; padding: 10px; background: #222; border-radius: 4px; }
    .legend-item { display: flex; align-items: center; gap: 8px; }
    .legend-color { width: 20px; height: 20px; border-radius: 3px; }
  </style>
</head>
<body>
  <h1>Support Cell Tests (Background Walls / Pillars)</h1>
  
  <div class="legend">
    <div class="legend-item">
      <div class="legend-color" style="background: #d4d8e0;"></div>
      <span>Regular Solid (blocks entities)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #5a4d42; background-image: linear-gradient(45deg, #5a4d42 25%, #524540 25%, #524540 50%, #5a4d42 50%, #5a4d42 75%, #524540 75%); background-size: 4px 4px;"></div>
      <span>Support Cell (entities pass through)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #111;"></div>
      <span>Empty (air)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #4f8; border-radius: 50%;"></div>
      <span>Entity</span>
    </div>
  </div>
  
  <p class="info">
    <strong>Support cells</strong> act as solid in the physics simulation (they don't fall, support structures above them) 
    but entities can walk through them. Think of them as background walls, pillars, or scaffolding.
  </p>
  
  <div class="controls">
    <button id="runAll">Run All Tests</button>
    <button id="stopTest">Stop</button>
  </div>
  <div class="info">Click a test to run it individually and watch the animation</div>
  <div id="results"></div>
  <h2>Visual Debug</h2>
  <canvas id="debugCanvas" width="512" height="288"></canvas>
  <pre id="log"></pre>

  <script>
    const GRID_W = 256;
    const GRID_H = 144;
    const results = document.getElementById('results');
    const logEl = document.getElementById('log');
    const canvas = document.getElementById('debugCanvas');
    const ctx = canvas.getContext('2d');

    let cpuCells = new Uint32Array(GRID_W * GRID_H);
    let logText = '';
    let currentAnimation = null;
    let testElements = [];

    function log(msg) {
      logText += msg + '\n';
      logEl.textContent = logText;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() {
      logText = '';
      logEl.textContent = '';
    }

    // ---- Cell helpers ----
    function getSolid(cell) {
      const dmg = cell & 0xff;
      const solidBit = (cell >> 8) & 1;
      return solidBit === 1 && dmg < 255;
    }

    function getPassable(cell) {
      return ((cell >> 9) & 1) === 1;
    }

    function isSupport(cell) {
      return getSolid(cell) && getPassable(cell);
    }

    function blocksEntity(cell) {
      return getSolid(cell) && !getPassable(cell);
    }

    // Set a regular solid cell (blocks entities)
    function setSolid(x, y) {
      if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return;
      cpuCells[y * GRID_W + x] = (0) | (1 << 8); // solid=1, passable=0
    }

    // Set a support cell (solid but entities can pass through)
    function setSupport(x, y) {
      if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return;
      cpuCells[y * GRID_W + x] = (0) | (1 << 8) | (1 << 9); // solid=1, passable=1
    }

    function clearGrid() {
      cpuCells.fill(0);
    }

    function drawGrid() {
      const scaleX = canvas.width / GRID_W;
      const scaleY = canvas.height / GRID_H;
      
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W; x++) {
          const cell = cpuCells[y * GRID_W + x];
          if (getSolid(cell)) {
            if (isSupport(cell)) {
              // Support cells: darker brownish with checkerboard pattern
              const pattern = (x + y) % 2 === 0;
              ctx.fillStyle = pattern ? '#5a4d42' : '#524540';
            } else {
              // Regular solid: light gray-blue
              ctx.fillStyle = '#d4d8e0';
            }
            ctx.fillRect(x * scaleX, y * scaleY, scaleX + 0.5, scaleY + 0.5);
          }
        }
      }
    }

    function drawPath(path, startX, startY, color = 'rgba(0, 255, 255, 0.4)') {
      if (path.length === 0) return;
      const scaleX = canvas.width / GRID_W;
      const scaleY = canvas.height / GRID_H;
      
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(startX * scaleX + scaleX / 2, startY * scaleY + scaleY / 2);
      for (const point of path) {
        ctx.lineTo(point.x * scaleX + scaleX / 2, point.y * scaleY + scaleY / 2);
      }
      ctx.stroke();
    }

    function drawEntity(x, y, color = '#0f0', radius = 6) {
      const scaleX = canvas.width / GRID_W;
      const scaleY = canvas.height / GRID_H;
      
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x * scaleX + scaleX / 2, y * scaleY + scaleY / 2, radius, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawPoint(x, y, color, label) {
      const scaleX = canvas.width / GRID_W;
      const scaleY = canvas.height / GRID_H;
      
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x * scaleX + scaleX / 2, y * scaleY + scaleY / 2, 4, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = '#fff';
      ctx.font = '12px sans-serif';
      ctx.fillText(label, x * scaleX + scaleX / 2 + 8, y * scaleY + scaleY / 2 + 4);
    }

    // ---- Pathfinding (updated for support cells) ----
    function isWalkable(x, y) {
      if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return false;
      const cell = cpuCells[y * GRID_W + x];
      // Can't walk inside blocking solid cells
      // Support cells (solid but passable) are treated as empty for entities
      if (blocksEntity(cell)) return false;
      // Check if there's solid ground below
      if (y + 1 >= GRID_H) return true;
      const below = cpuCells[(y + 1) * GRID_W + x];
      return getSolid(below);
    }

    function isJumpPathClear(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      
      if (dx === 0 && dy === 0) return true;
      
      const isFalling = dy > 0;
      
      if (isFalling) {
        for (let cy = y1 + 2; cy < y2; cy++) {
          if (cy < 0 || cy >= GRID_H) continue;
          const cell = cpuCells[cy * GRID_W + x1];
          if (blocksEntity(cell)) return false;
        }
        if (dx !== 0) {
          const stepX = dx > 0 ? 1 : -1;
          for (let cx = x1 + stepX; cx !== x2 + stepX; cx += stepX) {
            if (cx < 0 || cx >= GRID_W) continue;
            const cellAtLanding = cpuCells[y2 * GRID_W + cx];
            const cellAboveLanding = y2 > 0 ? cpuCells[(y2 - 1) * GRID_W + cx] : 0;
            if (blocksEntity(cellAtLanding) || blocksEntity(cellAboveLanding)) return false;
          }
        }
        return true;
      } else {
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        for (let i = 1; i < steps; i++) {
          const t = i / steps;
          const cx = Math.round(x1 + dx * t);
          const cy = Math.round(y1 + dy * t);
          if (cx < 0 || cx >= GRID_W || cy < 0 || cy >= GRID_H) continue;
          const cell = cpuCells[cy * GRID_W + cx];
          if (blocksEntity(cell)) return false;
        }
        return true;
      }
    }

    function isEdgeDropClear(x1, y1, x2, y2) {
      const edgeCell = cpuCells[y1 * GRID_W + x2];
      if (blocksEntity(edgeCell)) return false;
      for (let cy = y1 + 1; cy < y2; cy++) {
        if (cy < 0 || cy >= GRID_H) continue;
        const cell = cpuCells[cy * GRID_W + x2];
        if (blocksEntity(cell)) return false;
      }
      return true;
    }

    const MAX_JUMP_UP = 5;
    const MAX_JUMP_ACROSS = 3;

    function canTraverse(x1, y1, x2, y2) {
      if (!isWalkable(x2, y2)) return false;
      const dx = x2 - x1;
      const dy = y2 - y1;
      
      if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1) return true;
      if (dy < 0 && dy >= -MAX_JUMP_UP && Math.abs(dx) <= MAX_JUMP_ACROSS) {
        return isJumpPathClear(x1, y1, x2, y2);
      }
      if (dy > 0 && Math.abs(dx) <= MAX_JUMP_ACROSS) {
        if (Math.abs(dx) === 1 && dy > 1) {
          return isEdgeDropClear(x1, y1, x2, y2);
        }
        return isJumpPathClear(x1, y1, x2, y2);
      }
      return false;
    }

    function getTraversalCost(x1, y1, x2, y2) {
      const dx = Math.abs(x2 - x1);
      const dy = Math.abs(y2 - y1);
      const actualDy = y2 - y1;  // Positive = falling down
      
      // Regular walking
      if (dx <= 1 && dy <= 1) return dx !== 0 && dy !== 0 ? 1.414 : 1;
      
      const baseCost = Math.sqrt(dx * dx + dy * dy);
      
      // Jumping up has moderate cost
      if (actualDy < 0) {
        return baseCost * 1.5;
      }
      
      // Falling down has HIGH cost to prefer stairs
      // The further the fall, the higher the penalty
      return baseCost * 3.0 + (actualDy * 2.0);
    }

    function getPossibleMoves(x, y) {
      const moves = [];
      const walkDirs = [
        [-1, 0], [1, 0], [0, -1], [0, 1],
        [-1, -1], [1, -1], [-1, 1], [1, 1]
      ];
      for (const [dx, dy] of walkDirs) moves.push([dx, dy]);
      
      for (let jumpY = 2; jumpY <= MAX_JUMP_UP; jumpY++) {
        for (let jumpX = -MAX_JUMP_ACROSS; jumpX <= MAX_JUMP_ACROSS; jumpX++) {
          moves.push([jumpX, -jumpY]);
        }
      }
      
      for (let fallY = 2; fallY <= GRID_H; fallY++) {
        for (let fallX = -MAX_JUMP_ACROSS; fallX <= MAX_JUMP_ACROSS; fallX++) {
          const targetY = y + fallY;
          const targetX = x + fallX;
          if (targetY >= GRID_H) continue;
          if (isWalkable(targetX, targetY)) {
            moves.push([fallX, fallY]);
          }
        }
      }
      
      // Step off edge moves (updated for support cells)
      for (const stepX of [-1, 1]) {
        const edgeX = x + stepX;
        if (edgeX < 0 || edgeX >= GRID_W) continue;
        const edgeCell = cpuCells[y * GRID_W + edgeX];
        if (blocksEntity(edgeCell)) continue; // Can't step into blocking solid
        if (isWalkable(edgeX, y)) continue;
        
        for (let fallY = 1; fallY <= GRID_H; fallY++) {
          const landY = y + fallY;
          if (landY >= GRID_H) break;
          if (isWalkable(edgeX, landY)) {
            moves.push([stepX, fallY]);
            break;
          }
          const cellBelow = cpuCells[landY * GRID_W + edgeX];
          if (blocksEntity(cellBelow)) break; // Can't fall through blocking solid
        }
      }
      
      return moves;
    }

    function heuristic(x1, y1, x2, y2) {
      return Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1));
    }

    function findNearestWalkable(x, y) {
      if (isWalkable(x, y)) return { x, y };
      for (let r = 1; r < 20; r++) {
        for (let dy = -r; dy <= r; dy++) {
          for (let dx = -r; dx <= r; dx++) {
            if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
            const nx = x + dx;
            const ny = y + dy;
            if (isWalkable(nx, ny)) return { x: nx, y: ny };
          }
        }
      }
      return null;
    }

    function findPath(startX, startY, endX, endY) {
      startX = Math.max(0, Math.min(GRID_W - 1, startX));
      startY = Math.max(0, Math.min(GRID_H - 1, startY));
      endX = Math.max(0, Math.min(GRID_W - 1, endX));
      endY = Math.max(0, Math.min(GRID_H - 1, endY));

      const start = findNearestWalkable(startX, startY);
      const end = findNearestWalkable(endX, endY);
      
      if (!start || !end) return [];

      const key = (x, y) => `${x},${y}`;
      const openSet = new Map();
      const closedSet = new Set();
      const cameFrom = new Map();
      const gScore = new Map();
      const fScore = new Map();

      const startKey = key(start.x, start.y);
      gScore.set(startKey, 0);
      fScore.set(startKey, heuristic(start.x, start.y, end.x, end.y));
      openSet.set(startKey, start);

      let iterations = 0;
      const maxIterations = GRID_W * GRID_H * 2;

      while (openSet.size > 0 && iterations < maxIterations) {
        iterations++;

        let current = null;
        let currentKey = null;
        let lowestF = Infinity;
        for (const [k, node] of openSet) {
          const f = fScore.get(k) || Infinity;
          if (f < lowestF) {
            lowestF = f;
            current = node;
            currentKey = k;
          }
        }

        if (!current) break;

        if (current.x === end.x && current.y === end.y) {
          const path = [];
          let ck = currentKey;
          while (cameFrom.has(ck)) {
            const [px, py] = ck.split(',').map(Number);
            path.unshift({ x: px, y: py });
            ck = cameFrom.get(ck);
          }
          return path;
        }

        openSet.delete(currentKey);
        closedSet.add(currentKey);

        const moves = getPossibleMoves(current.x, current.y);
        
        for (const [dx, dy] of moves) {
          const nx = current.x + dx;
          const ny = current.y + dy;
          const nk = key(nx, ny);

          if (closedSet.has(nk)) continue;
          if (!canTraverse(current.x, current.y, nx, ny)) continue;

          const tentativeG = (gScore.get(currentKey) || 0) + 
            getTraversalCost(current.x, current.y, nx, ny);

          if (!openSet.has(nk)) {
            openSet.set(nk, { x: nx, y: ny });
          } else if (tentativeG >= (gScore.get(nk) || Infinity)) {
            continue;
          }

          cameFrom.set(nk, currentKey);
          gScore.set(nk, tentativeG);
          fScore.set(nk, tentativeG + heuristic(nx, ny, end.x, end.y));
        }
      }

      return [];
    }

    // Expand path with intermediate points
    function expandPath(path, startX, startY) {
      if (path.length === 0) return path;
      
      const expanded = [];
      let prevX = startX;
      let prevY = startY;
      
      for (const point of path) {
        const dx = point.x - prevX;
        const dy = point.y - prevY;
        const dist = Math.max(Math.abs(dx), Math.abs(dy));
        
        const isFalling = dy > 0 && Math.abs(dy) > 1;
        
        if (dist > 1) {
          const steps = dist;
          for (let i = 1; i <= steps; i++) {
            const t = i / steps;
            expanded.push({
              x: prevX + dx * t,
              y: prevY + dy * t,
              falling: isFalling,
              fallIndex: isFalling ? i : 0,
            });
          }
        } else {
          expanded.push({ x: point.x, y: point.y, falling: false, fallIndex: 0 });
        }
        
        prevX = point.x;
        prevY = point.y;
      }
      
      return expanded;
    }

    // ---- Animation System ----
    class AnimatedEntity {
      constructor(x, y, color = '#0f0') {
        this.x = x;
        this.y = y;
        this.color = color;
        this.path = [];
        this.baseSpeed = 0.15;
        this.currentSpeed = 0.15;
        this.moveProgress = 0;
        this.fallVelocity = 0;
      }
      
      update() {
        if (this.path.length === 0) {
          this.fallVelocity = 0;
          this.currentSpeed = this.baseSpeed;
          return false;
        }
        
        const nextPoint = this.path[0];
        const GRAVITY = 0.08;
        const MAX_FALL_SPEED = 1.5;
        
        if (nextPoint.falling) {
          this.fallVelocity = Math.min(this.fallVelocity + GRAVITY, MAX_FALL_SPEED);
          this.currentSpeed = Math.max(0.1, this.fallVelocity);
        } else {
          this.currentSpeed = this.baseSpeed;
          this.fallVelocity = 0;
        }
        
        this.moveProgress += this.currentSpeed;
        if (this.moveProgress >= 1) {
          this.moveProgress = 0;
          const next = this.path.shift();
          if (next) {
            this.x = next.x;
            this.y = next.y;
          }
        }
        
        return true;
      }
      
      draw() {
        drawEntity(this.x, this.y, this.color);
      }
    }

    // ---- Test Cases ----
    const tests = [
      {
        name: 'Walk through single support pillar',
        description: 'Entity should walk straight through a support cell',
        setup: () => {
          clearGrid();
          // Ground
          for (let x = 0; x < GRID_W; x++) setSolid(x, 101);
          // Single support pillar in the middle of the path
          setSupport(80, 100);
          return { startX: 60, startY: 100, endX: 100, endY: 100 };
        }
      },
      {
        name: 'Walk through support wall',
        description: 'Entity should walk through a vertical wall of support cells',
        setup: () => {
          clearGrid();
          // Ground
          for (let x = 0; x < GRID_W; x++) setSolid(x, 101);
          // Vertical support wall
          for (let y = 96; y < 101; y++) setSupport(80, y);
          return { startX: 60, startY: 100, endX: 100, endY: 100 };
        }
      },
      {
        name: 'Cannot walk through regular solid wall',
        description: 'Entity should NOT be able to path through a regular solid wall (must go around or fail)',
        setup: () => {
          clearGrid();
          // Ground
          for (let x = 0; x < GRID_W; x++) setSolid(x, 101);
          // Solid wall blocking path
          for (let y = 95; y < 101; y++) setSolid(80, y);
          return { startX: 60, startY: 100, endX: 100, endY: 100 };
        },
        expectFail: true // No path should be found or must go around
      },
      {
        name: 'Walk on support cell floor (support below)',
        description: 'Entity can walk on top of support cells (they act as solid ground)',
        setup: () => {
          clearGrid();
          // Regular ground on sides
          for (let x = 0; x < 60; x++) setSolid(x, 101);
          for (let x = 100; x < GRID_W; x++) setSolid(x, 101);
          // Support cell floor in the middle
          for (let x = 60; x < 100; x++) setSupport(x, 101);
          return { startX: 40, startY: 100, endX: 120, endY: 100 };
        }
      },
      {
        name: 'Fall through support cells',
        description: 'Entity should fall through support cells to land on solid ground below',
        setup: () => {
          clearGrid();
          // Upper platform
          for (let x = 50; x < 80; x++) setSolid(x, 51);
          // Support cells in the middle (entity falls through)
          for (let y = 60; y < 90; y++) {
            for (let x = 55; x < 75; x++) setSupport(x, y);
          }
          // Ground below
          for (let x = 0; x < GRID_W; x++) setSolid(x, 101);
          return { startX: 65, startY: 50, endX: 65, endY: 100 };
        }
      },
      {
        name: 'Mixed: support scaffolding with solid platforms',
        description: 'Complex structure with support scaffolding and solid walkways',
        setup: () => {
          clearGrid();
          // Ground
          for (let x = 0; x < GRID_W; x++) setSolid(x, 121);
          
          // Connected platform structure:
          // Left section: solid ground with support scaffolding on top
          for (let x = 30; x < 90; x++) setSolid(x, 101);  // Continuous platform
          
          // Support scaffolding in the middle of the platform (entity walks through)
          for (let y = 96; y < 101; y++) {
            for (let x = 55; x < 75; x++) setSupport(x, y);
          }
          
          // Right section connected by support bridge
          for (let x = 90; x < 140; x++) setSolid(x, 101);  // Right platform
          
          // Support columns as decoration (entity can walk through these)
          for (let y = 90; y < 101; y++) {
            setSupport(45, y);   // Left column
            setSupport(115, y);  // Right column
          }
          
          // Entity walks from left, through support scaffolding, to right
          return { startX: 35, startY: 100, endX: 130, endY: 100 };
        }
      },
      {
        name: 'Walk through support tunnel',
        description: 'Horizontal tunnel made of support cells - entity walks through it',
        setup: () => {
          clearGrid();
          // Ground
          for (let x = 0; x < GRID_W; x++) setSolid(x, 101);
          
          // Tunnel made of support cells (top and sides, but ground is solid)
          // Ceiling
          for (let x = 60; x < 100; x++) setSupport(x, 97);
          // Walls
          for (let y = 97; y < 101; y++) {
            setSupport(60, y);
            setSupport(99, y);
          }
          
          return { startX: 40, startY: 100, endX: 120, endY: 100 };
        }
      },
      {
        name: 'Support pillars array',
        description: 'Walk through a grid of support pillars',
        setup: () => {
          clearGrid();
          // Ground
          for (let x = 0; x < GRID_W; x++) setSolid(x, 101);
          
          // Grid of support pillars
          for (let px = 50; px < 110; px += 10) {
            for (let y = 96; y < 101; y++) {
              setSupport(px, y);
            }
          }
          
          return { startX: 30, startY: 100, endX: 130, endY: 100 };
        }
      },
      {
        name: 'Multi-room building with staircases',
        description: '4-story building with support pillar walls and staircases connecting floors',
        setup: () => {
          clearGrid();
          
          // Building dimensions
          const buildingLeft = 60;
          const buildingRight = 180;
          const floorHeight = 18;  // Height between floors
          const numFloors = 4;
          const stairWidth = 20;   // Width of stairwell opening
          
          // Ground level
          const groundY = 120;
          for (let x = 0; x < GRID_W; x++) setSolid(x, groundY);
          
          // Calculate stairwell positions (alternating sides)
          const leftStairX = buildingLeft + 5;
          const rightStairX = buildingRight - stairWidth - 5;
          
          // Build each floor
          for (let floor = 0; floor < numFloors; floor++) {
            const floorY = groundY - (floor + 1) * floorHeight;
            
            // Determine which staircase comes UP to this floor (from floor below)
            // Floor 0 has no stairs coming up to it (it's the bottom)
            // Floor 1 has stairs from floor 0 (which uses right side)
            // Floor 2 has stairs from floor 1 (which uses left side)
            // etc.
            const stairsFromBelow = floor > 0;
            const belowUsedRightStair = ((floor - 1) % 2 === 0);
            const stairFromBelowX = belowUsedRightStair ? rightStairX : leftStairX;
            
            // Floor surface - use SUPPORT cells for stairwell area
            // This allows entities to walk ON TOP (solid floor) and also THROUGH (for stairs)
            for (let x = buildingLeft; x < buildingRight; x++) {
              const inStairwell = stairsFromBelow && 
                                  (x >= stairFromBelowX && x < stairFromBelowX + stairWidth);
              if (inStairwell) {
                setSupport(x, floorY);  // Support: walkable on top AND passable through
              } else {
                setSolid(x, floorY);    // Regular solid floor
              }
            }
            
            // Left wall (support pillars - entities can pass through)
            for (let y = floorY - floorHeight + 2; y < floorY; y++) {
              setSupport(buildingLeft, y);
              setSupport(buildingLeft + 1, y);
            }
            
            // Right wall (support pillars)
            for (let y = floorY - floorHeight + 2; y < floorY; y++) {
              setSupport(buildingRight - 1, y);
              setSupport(buildingRight - 2, y);
            }
            
            // Staircase going UP to next floor
            // Stairs start from CENTER side (accessible) and go toward the WALL side
            if (floor < numFloors - 1) {
              const useRightStair = (floor % 2 === 0);
              const stairX = useRightStair ? rightStairX : leftStairX;
              const stepsNeeded = floorHeight - 1;
              
              for (let step = 0; step < stepsNeeded; step++) {
                const stepY = floorY - step - 1;  // Going up
                // Start from center side, go toward wall
                const stepX = useRightStair 
                  ? stairX + step              // Start left (center), go right (toward wall)
                  : stairX + stairWidth - 3 - step;  // Start right (center), go left (toward wall)
                
                // Make step 3 cells wide
                for (let w = 0; w < 3; w++) {
                  const sx = stepX + w;
                  if (sx >= buildingLeft + 2 && sx < buildingRight - 2) {
                    setSolid(sx, stepY);
                  }
                }
              }
            }
            
            // Interior support column (single, in the middle)
            const midX = Math.floor((buildingLeft + buildingRight) / 2);
            for (let y = floorY - floorHeight + 2; y < floorY; y++) {
              setSupport(midX, y);
            }
          }
          
          // Entity starts on first floor, needs to reach top floor
          const startX = buildingLeft + 15;
          const startY = groundY - floorHeight - 1;  // On first floor
          
          // End position: on top floor
          const endX = buildingRight - 15;
          const endY = groundY - numFloors * floorHeight - 1;  // On top floor
          
          return { startX, startY, endX, endY };
        }
      },
      {
        name: 'Multi-room building with SUPPORT staircases',
        description: '4-story building with support stairs - entities can walk on and through the stairs',
        setup: () => {
          clearGrid();
          
          // Building dimensions
          const buildingLeft = 60;
          const buildingRight = 180;
          const floorHeight = 18;
          const numFloors = 4;
          const stairWidth = 20;
          
          // Ground level
          const groundY = 120;
          for (let x = 0; x < GRID_W; x++) setSolid(x, groundY);
          
          // Calculate stairwell positions (alternating sides)
          const leftStairX = buildingLeft + 5;
          const rightStairX = buildingRight - stairWidth - 5;
          
          // Build each floor
          for (let floor = 0; floor < numFloors; floor++) {
            const floorY = groundY - (floor + 1) * floorHeight;
            
            const stairsFromBelow = floor > 0;
            const belowUsedRightStair = ((floor - 1) % 2 === 0);
            const stairFromBelowX = belowUsedRightStair ? rightStairX : leftStairX;
            
            // Floor surface - use SUPPORT cells for stairwell area
            for (let x = buildingLeft; x < buildingRight; x++) {
              const inStairwell = stairsFromBelow && 
                                  (x >= stairFromBelowX && x < stairFromBelowX + stairWidth);
              if (inStairwell) {
                setSupport(x, floorY);
              } else {
                // Thick solid floor
                setSolid(x, floorY);
                setSolid(x, floorY + 1);
              }
            }
            
            // Left wall (support pillars)
            for (let y = floorY - floorHeight + 2; y < floorY; y++) {
              setSupport(buildingLeft, y);
              setSupport(buildingLeft + 1, y);
            }
            
            // Right wall (support pillars)
            for (let y = floorY - floorHeight + 2; y < floorY; y++) {
              setSupport(buildingRight - 1, y);
              setSupport(buildingRight - 2, y);
            }
            
            // Staircase going UP to next floor - USING SUPPORT TILES
            if (floor < numFloors - 1) {
              const useRightStair = (floor % 2 === 0);
              const stairX = useRightStair ? rightStairX : leftStairX;
              const stepsNeeded = floorHeight - 1;
              
              for (let step = 0; step < stepsNeeded; step++) {
                const stepY = floorY - step - 1;
                const stepX = useRightStair 
                  ? stairX + step
                  : stairX + stairWidth - 3 - step;
                
                // Make step 3 cells wide - SUPPORT TILES
                for (let w = 0; w < 3; w++) {
                  const sx = stepX + w;
                  if (sx >= buildingLeft + 2 && sx < buildingRight - 2) {
                    setSupport(sx, stepY);  // Support stairs!
                  }
                }
              }
            }
            
            // Interior support column
            const midX = Math.floor((buildingLeft + buildingRight) / 2);
            for (let y = floorY - floorHeight + 2; y < floorY; y++) {
              setSupport(midX, y);
            }
          }
          
          // Entity starts on first floor, needs to reach top floor
          const startX = buildingLeft + 15;
          const startY = groundY - floorHeight - 1;
          
          // End position: on top floor
          const endX = buildingRight - 15;
          const endY = groundY - numFloors * floorHeight - 1;
          
          return { startX, startY, endX, endY };
        }
      },
      {
        name: 'Multi-room building REVERSE (top to bottom)',
        description: '4-story building - entity descends from top floor to bottom via staircases',
        setup: () => {
          clearGrid();
          
          // Building dimensions (same as forward test)
          const buildingLeft = 60;
          const buildingRight = 180;
          const floorHeight = 18;
          const numFloors = 4;
          const stairWidth = 20;
          
          // Ground level
          const groundY = 120;
          for (let x = 0; x < GRID_W; x++) setSolid(x, groundY);
          
          // Calculate stairwell positions (alternating sides)
          const leftStairX = buildingLeft + 5;
          const rightStairX = buildingRight - stairWidth - 5;
          
          // Build each floor (identical to forward test)
          for (let floor = 0; floor < numFloors; floor++) {
            const floorY = groundY - (floor + 1) * floorHeight;
            
            const stairsFromBelow = floor > 0;
            const belowUsedRightStair = ((floor - 1) % 2 === 0);
            const stairFromBelowX = belowUsedRightStair ? rightStairX : leftStairX;
            
            // Floor surface - use SUPPORT cells for stairwell area
            for (let x = buildingLeft; x < buildingRight; x++) {
              const inStairwell = stairsFromBelow && 
                                  (x >= stairFromBelowX && x < stairFromBelowX + stairWidth);
              if (inStairwell) {
                setSupport(x, floorY);
              } else {
                // Make solid floor thicker to prevent falling through
                setSolid(x, floorY);
                setSolid(x, floorY + 1);
              }
            }
            
            // Left wall - simple support pillars
            for (let y = floorY - floorHeight + 2; y < floorY; y++) {
              setSupport(buildingLeft, y);
              setSupport(buildingLeft + 1, y);
            }
            
            // Right wall - simple support pillars
            for (let y = floorY - floorHeight + 2; y < floorY; y++) {
              setSupport(buildingRight - 1, y);
              setSupport(buildingRight - 2, y);
            }
            
            // Staircase going UP to next floor
            if (floor < numFloors - 1) {
              const useRightStair = (floor % 2 === 0);
              const stairX = useRightStair ? rightStairX : leftStairX;
              const stepsNeeded = floorHeight - 1;
              
              for (let step = 0; step < stepsNeeded; step++) {
                const stepY = floorY - step - 1;
                const stepX = useRightStair 
                  ? stairX + step
                  : stairX + stairWidth - 3 - step;
                
                for (let w = 0; w < 3; w++) {
                  const sx = stepX + w;
                  if (sx >= buildingLeft + 2 && sx < buildingRight - 2) {
                    setSolid(sx, stepY);
                  }
                }
              }
            }
            
            // Interior column - simple support pillar
            const midX = Math.floor((buildingLeft + buildingRight) / 2);
            for (let y = floorY - floorHeight + 2; y < floorY; y++) {
              setSupport(midX, y);
            }
          }
          
          // REVERSED: Entity starts on TOP floor, needs to reach BOTTOM floor
          const startX = buildingRight - 15;
          const startY = groundY - numFloors * floorHeight - 1;  // On top floor
          
          // End position: on first floor
          const endX = buildingLeft + 15;
          const endY = groundY - floorHeight - 1;  // On first floor
          
          return { startX, startY, endX, endY };
        }
      },
    ];

    function stopAnimation() {
      if (currentAnimation) {
        cancelAnimationFrame(currentAnimation);
        currentAnimation = null;
      }
    }

    function runAnimatedTest(test, element) {
      stopAnimation();
      clearLog();
      
      log(`Running: ${test.name}`);
      log(`Description: ${test.description}`);
      
      const { startX, startY, endX, endY } = test.setup();
      
      log(`Start: (${startX}, ${startY}), End: (${endX}, ${endY})`);
      log(`isWalkable(start): ${isWalkable(startX, startY)}`);
      log(`isWalkable(end): ${isWalkable(endX, endY)}`);
      
      const path = findPath(startX, startY, endX, endY);
      log(`Path found: ${path.length} steps`);
      
      if (path.length === 0) {
        drawGrid();
        drawPoint(startX, startY, '#0f0', 'Start');
        drawPoint(endX, endY, '#f00', 'End');
        
        if (test.expectFail) {
          element.className = 'test pass';
          element.querySelector('small').textContent = 'No path (expected - wall blocks)';
          log('✓ PASSED - No path found as expected (wall blocks entity)');
        } else {
          element.className = 'test fail';
          element.querySelector('small').textContent = 'No path found';
          log('✗ FAILED - No path found');
        }
        return;
      }
      
      if (test.expectFail) {
        // If we expected failure but found a path, that's wrong
        // Unless the path goes around the obstacle
        log(`Note: Found a path when expecting potential failure. Path may go around obstacle.`);
      }
      
      const expandedPath = expandPath(path, startX, startY);
      log(`Expanded path: ${expandedPath.length} steps`);
      
      const entity = new AnimatedEntity(startX, startY, '#4f8');
      entity.path = [...expandedPath];
      
      element.className = 'test running';
      element.querySelector('small').textContent = 'Running...';
      
      function animate() {
        drawGrid();
        drawPath(expandedPath, startX, startY);
        drawPoint(startX, startY, 'rgba(0, 255, 0, 0.5)', 'Start');
        drawPoint(endX, endY, 'rgba(255, 100, 100, 0.8)', 'End');
        entity.draw();
        
        const stillMoving = entity.update();
        
        if (stillMoving) {
          currentAnimation = requestAnimationFrame(animate);
        } else {
          const dist = Math.abs(entity.x - endX) + Math.abs(entity.y - endY);
          const nearEnd = findNearestWalkable(endX, endY);
          const distToNearEnd = nearEnd ? Math.abs(entity.x - nearEnd.x) + Math.abs(entity.y - nearEnd.y) : Infinity;
          
          if (dist <= 2 || distToNearEnd <= 2) {
            element.className = 'test pass';
            element.querySelector('small').textContent = `Reached destination in ${expandedPath.length} steps`;
            log('✓ PASSED - Entity reached destination');
          } else {
            element.className = 'test fail';
            element.querySelector('small').textContent = `Stopped at (${entity.x.toFixed(1)}, ${entity.y.toFixed(1)})`;
            log(`✗ FAILED - Entity stopped at (${entity.x}, ${entity.y})`);
          }
          currentAnimation = null;
        }
      }
      
      animate();
    }

    function createTestElement(test, index) {
      const div = document.createElement('div');
      div.className = 'test pending';
      div.innerHTML = `<strong>${test.name}</strong><br><small>Click to run</small>`;
      div.addEventListener('click', () => runAnimatedTest(test, div));
      results.appendChild(div);
      testElements.push({ test, element: div });
      return div;
    }

    async function runAllTests() {
      for (const { test, element } of testElements) {
        await new Promise(resolve => {
          runAnimatedTest(test, element);
          
          const checkComplete = () => {
            if (!currentAnimation) {
              setTimeout(resolve, 500);
            } else {
              setTimeout(checkComplete, 100);
            }
          };
          checkComplete();
        });
      }
    }

    // Setup
    tests.forEach((test, i) => createTestElement(test, i));
    
    document.getElementById('runAll').addEventListener('click', runAllTests);
    document.getElementById('stopTest').addEventListener('click', stopAnimation);
    
    // Run first test by default
    if (testElements.length > 0) {
      runAnimatedTest(testElements[0].test, testElements[0].element);
    }
  </script>
</body>
</html>
