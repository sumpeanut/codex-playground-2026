<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Pathfinding Test</title>
  <style>
    body { font-family: system-ui, sans-serif; background: #1a1a1a; color: #eee; padding: 20px; }
    .test { margin: 10px 0; padding: 10px; border-radius: 6px; cursor: pointer; }
    .test:hover { opacity: 0.8; }
    .pass { background: #1a4a1a; border: 1px solid #2a6a2a; }
    .fail { background: #4a1a1a; border: 1px solid #6a2a2a; }
    .pending { background: #3a3a1a; border: 1px solid #5a5a2a; }
    .running { background: #1a3a4a; border: 1px solid #2a5a6a; }
    canvas { border: 1px solid #444; margin: 10px 0; display: block; }
    pre { background: #222; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 12px; max-height: 200px; overflow-y: auto; }
    h2 { margin-top: 30px; }
    .controls { margin: 10px 0; }
    button { background: #333; color: #eee; border: 1px solid #555; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 8px; }
    button:hover { background: #444; }
    .info { font-size: 12px; opacity: 0.7; margin-top: 5px; }
  </style>
</head>
<body>
  <h1>Pathfinding Tests</h1>
  <div class="controls">
    <button id="runAll">Run All Tests</button>
    <button id="stopTest">Stop</button>
  </div>
  <div class="info">Click a test to run it individually and watch the animation</div>
  <div id="results"></div>
  <h2>Visual Debug</h2>
  <canvas id="debugCanvas" width="512" height="288"></canvas>
  <pre id="log"></pre>

  <!--
    CA test harness:
    - window.caTest.run() / window.caTest.getStatus()
    - postMessage events: ca-test-status, ca-test-result
    - supports ?autorun=1
  -->
  <script>
    const caTestState = {
      name: 'pathfinding',
      status: 'idle',
      passed: null,
      details: null,
    };

    function postCaStatus(status, details = null) {
      caTestState.status = status;
      caTestState.details = details;
      if (window.parent) {
        window.parent.postMessage({
          type: 'ca-test-status',
          name: caTestState.name,
          status,
          details,
        }, '*');
      }
    }

    function postCaResult(passed, details = null) {
      caTestState.status = passed ? 'pass' : 'fail';
      caTestState.passed = passed;
      caTestState.details = details;
      if (window.parent) {
        window.parent.postMessage({
          type: 'ca-test-result',
          name: caTestState.name,
          passed,
          details,
        }, '*');
      }
    }
    const GRID_W = 256;
    const GRID_H = 144;
    const results = document.getElementById('results');
    const logEl = document.getElementById('log');
    const canvas = document.getElementById('debugCanvas');
    const ctx = canvas.getContext('2d');

    let cpuCells = new Uint32Array(GRID_W * GRID_H);
    let logText = '';
    let currentAnimation = null;
    let testElements = [];

    function log(msg) {
      logText += msg + '\n';
      logEl.textContent = logText;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() {
      logText = '';
      logEl.textContent = '';
    }

    function getSolid(cell) {
      const dmg = cell & 0xff;
      const solidBit = (cell >> 8) & 1;
      return solidBit === 1 && dmg < 255;
    }

    function setSolid(x, y) {
      if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return;
      cpuCells[y * GRID_W + x] = (0) | (1 << 8);
    }

    function clearGrid() {
      cpuCells.fill(0);
    }

    function drawGrid() {
      const scaleX = canvas.width / GRID_W;
      const scaleY = canvas.height / GRID_H;
      
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W; x++) {
          if (getSolid(cpuCells[y * GRID_W + x])) {
            ctx.fillStyle = '#556';
            ctx.fillRect(x * scaleX, y * scaleY, scaleX + 0.5, scaleY + 0.5);
          }
        }
      }
    }

    function drawPath(path, startX, startY, color = 'rgba(0, 255, 255, 0.4)') {
      if (path.length === 0) return;
      const scaleX = canvas.width / GRID_W;
      const scaleY = canvas.height / GRID_H;
      
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(startX * scaleX + scaleX / 2, startY * scaleY + scaleY / 2);
      for (const point of path) {
        ctx.lineTo(point.x * scaleX + scaleX / 2, point.y * scaleY + scaleY / 2);
      }
      ctx.stroke();
    }

    function drawEntity(x, y, color = '#0f0', radius = 6) {
      const scaleX = canvas.width / GRID_W;
      const scaleY = canvas.height / GRID_H;
      
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x * scaleX + scaleX / 2, y * scaleY + scaleY / 2, radius, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawPoint(x, y, color, label) {
      const scaleX = canvas.width / GRID_W;
      const scaleY = canvas.height / GRID_H;
      
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x * scaleX + scaleX / 2, y * scaleY + scaleY / 2, 4, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = '#fff';
      ctx.font = '12px sans-serif';
      ctx.fillText(label, x * scaleX + scaleX / 2 + 8, y * scaleY + scaleY / 2 + 4);
    }

    // ---- Copy of pathfinding code ----
    function isWalkable(x, y) {
      if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return false;
      const cell = cpuCells[y * GRID_W + x];
      if (getSolid(cell)) return false;
      if (y + 1 >= GRID_H) return true;
      const below = cpuCells[(y + 1) * GRID_W + x];
      return getSolid(below);
    }

    function isJumpPathClear(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      
      if (dx === 0 && dy === 0) return true;
      
      const isFalling = dy > 0;
      
      if (isFalling) {
        for (let cy = y1 + 2; cy < y2; cy++) {
          if (cy < 0 || cy >= GRID_H) continue;
          const cell = cpuCells[cy * GRID_W + x1];
          if (getSolid(cell)) return false;
        }
        if (dx !== 0) {
          const stepX = dx > 0 ? 1 : -1;
          for (let cx = x1 + stepX; cx !== x2 + stepX; cx += stepX) {
            if (cx < 0 || cx >= GRID_W) continue;
            const cellAtLanding = cpuCells[y2 * GRID_W + cx];
            const cellAboveLanding = y2 > 0 ? cpuCells[(y2 - 1) * GRID_W + cx] : 0;
            if (getSolid(cellAtLanding) || getSolid(cellAboveLanding)) return false;
          }
        }
        return true;
      } else {
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        for (let i = 1; i < steps; i++) {
          const t = i / steps;
          const cx = Math.round(x1 + dx * t);
          const cy = Math.round(y1 + dy * t);
          if (cx < 0 || cx >= GRID_W || cy < 0 || cy >= GRID_H) continue;
          const cell = cpuCells[cy * GRID_W + cx];
          if (getSolid(cell)) return false;
        }
        return true;
      }
    }

    function isEdgeDropClear(x1, y1, x2, y2) {
      const edgeCell = cpuCells[y1 * GRID_W + x2];
      if (getSolid(edgeCell)) return false;
      for (let cy = y1 + 1; cy < y2; cy++) {
        if (cy < 0 || cy >= GRID_H) continue;
        const cell = cpuCells[cy * GRID_W + x2];
        if (getSolid(cell)) return false;
      }
      return true;
    }

    const MAX_JUMP_UP = 5;
    const MAX_JUMP_ACROSS = 3;

    function canTraverse(x1, y1, x2, y2) {
      if (!isWalkable(x2, y2)) return false;
      const dx = x2 - x1;
      const dy = y2 - y1;
      
      if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1) return true;
      if (dy < 0 && dy >= -MAX_JUMP_UP && Math.abs(dx) <= MAX_JUMP_ACROSS) {
        return isJumpPathClear(x1, y1, x2, y2);
      }
      if (dy > 0 && Math.abs(dx) <= MAX_JUMP_ACROSS) {
        if (Math.abs(dx) === 1 && dy > 1) {
          return isEdgeDropClear(x1, y1, x2, y2);
        }
        return isJumpPathClear(x1, y1, x2, y2);
      }
      return false;
    }

    function getTraversalCost(x1, y1, x2, y2) {
      const dx = Math.abs(x2 - x1);
      const dy = Math.abs(y2 - y1);
      if (dx <= 1 && dy <= 1) return dx !== 0 && dy !== 0 ? 1.414 : 1;
      return Math.sqrt(dx * dx + dy * dy) * 1.5;
    }

    function getPossibleMoves(x, y) {
      const moves = [];
      const walkDirs = [
        [-1, 0], [1, 0], [0, -1], [0, 1],
        [-1, -1], [1, -1], [-1, 1], [1, 1]
      ];
      for (const [dx, dy] of walkDirs) moves.push([dx, dy]);
      
      for (let jumpY = 2; jumpY <= MAX_JUMP_UP; jumpY++) {
        for (let jumpX = -MAX_JUMP_ACROSS; jumpX <= MAX_JUMP_ACROSS; jumpX++) {
          moves.push([jumpX, -jumpY]);
        }
      }
      
      for (let fallY = 2; fallY <= GRID_H; fallY++) {
        for (let fallX = -MAX_JUMP_ACROSS; fallX <= MAX_JUMP_ACROSS; fallX++) {
          const targetY = y + fallY;
          const targetX = x + fallX;
          if (targetY >= GRID_H) continue;
          if (isWalkable(targetX, targetY)) {
            moves.push([fallX, fallY]);
          }
        }
      }
      
      // Step off edge moves
      for (const stepX of [-1, 1]) {
        const edgeX = x + stepX;
        if (edgeX < 0 || edgeX >= GRID_W) continue;
        const edgeCell = cpuCells[y * GRID_W + edgeX];
        if (getSolid(edgeCell)) continue;
        if (isWalkable(edgeX, y)) continue;
        
        for (let fallY = 1; fallY <= GRID_H; fallY++) {
          const landY = y + fallY;
          if (landY >= GRID_H) break;
          if (isWalkable(edgeX, landY)) {
            moves.push([stepX, fallY]);
            break;
          }
          const cellBelow = cpuCells[landY * GRID_W + edgeX];
          if (getSolid(cellBelow)) break;
        }
      }
      
      return moves;
    }

    function heuristic(x1, y1, x2, y2) {
      return Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1));
    }

    function findNearestWalkable(x, y) {
      if (isWalkable(x, y)) return { x, y };
      for (let r = 1; r < 20; r++) {
        for (let dy = -r; dy <= r; dy++) {
          for (let dx = -r; dx <= r; dx++) {
            if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
            const nx = x + dx;
            const ny = y + dy;
            if (isWalkable(nx, ny)) return { x: nx, y: ny };
          }
        }
      }
      return null;
    }

    function findPath(startX, startY, endX, endY) {
      startX = Math.max(0, Math.min(GRID_W - 1, startX));
      startY = Math.max(0, Math.min(GRID_H - 1, startY));
      endX = Math.max(0, Math.min(GRID_W - 1, endX));
      endY = Math.max(0, Math.min(GRID_H - 1, endY));

      const start = findNearestWalkable(startX, startY);
      const end = findNearestWalkable(endX, endY);
      
      if (!start || !end) return [];

      const key = (x, y) => `${x},${y}`;
      const openSet = new Map();
      const closedSet = new Set();
      const cameFrom = new Map();
      const gScore = new Map();
      const fScore = new Map();

      const startKey = key(start.x, start.y);
      gScore.set(startKey, 0);
      fScore.set(startKey, heuristic(start.x, start.y, end.x, end.y));
      openSet.set(startKey, start);

      let iterations = 0;
      const maxIterations = GRID_W * GRID_H * 2;

      while (openSet.size > 0 && iterations < maxIterations) {
        iterations++;

        let current = null;
        let currentKey = null;
        let lowestF = Infinity;
        for (const [k, node] of openSet) {
          const f = fScore.get(k) || Infinity;
          if (f < lowestF) {
            lowestF = f;
            current = node;
            currentKey = k;
          }
        }

        if (!current) break;

        if (current.x === end.x && current.y === end.y) {
          const path = [];
          let ck = currentKey;
          while (cameFrom.has(ck)) {
            const [px, py] = ck.split(',').map(Number);
            path.unshift({ x: px, y: py });
            ck = cameFrom.get(ck);
          }
          return path;
        }

        openSet.delete(currentKey);
        closedSet.add(currentKey);

        const moves = getPossibleMoves(current.x, current.y);
        
        for (const [dx, dy] of moves) {
          const nx = current.x + dx;
          const ny = current.y + dy;
          const nk = key(nx, ny);

          if (closedSet.has(nk)) continue;
          if (!canTraverse(current.x, current.y, nx, ny)) continue;

          const tentativeG = (gScore.get(currentKey) || 0) + 
            getTraversalCost(current.x, current.y, nx, ny);

          if (!openSet.has(nk)) {
            openSet.set(nk, { x: nx, y: ny });
          } else if (tentativeG >= (gScore.get(nk) || Infinity)) {
            continue;
          }

          cameFrom.set(nk, currentKey);
          gScore.set(nk, tentativeG);
          fScore.set(nk, tentativeG + heuristic(nx, ny, end.x, end.y));
        }
      }

      return [];
    }

    // Expand path with intermediate points
    function expandPath(path, startX, startY) {
      if (path.length === 0) return path;
      
      const expanded = [];
      let prevX = startX;
      let prevY = startY;
      
      for (const point of path) {
        const dx = point.x - prevX;
        const dy = point.y - prevY;
        const dist = Math.max(Math.abs(dx), Math.abs(dy));
        
        const isFalling = dy > 0 && Math.abs(dy) > 1;
        
        if (dist > 1) {
          const steps = dist;
          for (let i = 1; i <= steps; i++) {
            const t = i / steps;
            expanded.push({
              x: prevX + dx * t,
              y: prevY + dy * t,
              falling: isFalling,
              fallIndex: isFalling ? i : 0,
            });
          }
        } else {
          expanded.push({ x: point.x, y: point.y, falling: false, fallIndex: 0 });
        }
        
        prevX = point.x;
        prevY = point.y;
      }
      
      return expanded;
    }

    // ---- Animation System ----
    class AnimatedEntity {
      constructor(x, y, color = '#0f0') {
        this.x = x;
        this.y = y;
        this.color = color;
        this.path = [];
        this.baseSpeed = 0.15;
        this.currentSpeed = 0.15;
        this.moveProgress = 0;
        this.fallVelocity = 0;
      }
      
      update() {
        if (this.path.length === 0) {
          this.fallVelocity = 0;
          this.currentSpeed = this.baseSpeed;
          return false; // Not moving
        }
        
        const nextPoint = this.path[0];
        const GRAVITY = 0.08;
        const MAX_FALL_SPEED = 1.5;
        
        if (nextPoint.falling) {
          this.fallVelocity = Math.min(this.fallVelocity + GRAVITY, MAX_FALL_SPEED);
          this.currentSpeed = Math.max(0.1, this.fallVelocity);
        } else {
          this.currentSpeed = this.baseSpeed;
          this.fallVelocity = 0;
        }
        
        this.moveProgress += this.currentSpeed;
        if (this.moveProgress >= 1) {
          this.moveProgress = 0;
          const next = this.path.shift();
          if (next) {
            this.x = next.x;
            this.y = next.y;
          }
        }
        
        return true; // Still moving
      }
      
      draw() {
        drawEntity(this.x, this.y, this.color);
      }
    }

    // ---- Test Cases ----
    const tests = [
      {
        name: 'Simple fall 10 units',
        setup: () => {
          clearGrid();
          for (let x = 50; x < 70; x++) setSolid(x, 51);
          for (let x = 0; x < GRID_W; x++) setSolid(x, 101);
          return { startX: 60, startY: 50, endX: 60, endY: 100 };
        }
      },
      {
        name: 'Long fall 50 units',
        setup: () => {
          clearGrid();
          for (let x = 50; x < 70; x++) setSolid(x, 31);
          for (let x = 0; x < GRID_W; x++) setSolid(x, 121);
          return { startX: 60, startY: 30, endX: 60, endY: 120 };
        }
      },
      {
        name: 'Step off edge and fall',
        setup: () => {
          clearGrid();
          // Platform
          for (let x = 50; x < 70; x++) setSolid(x, 41);
          // Ground
          for (let x = 0; x < GRID_W; x++) setSolid(x, 121);
          return { startX: 60, startY: 40, endX: 100, endY: 120 };
        }
      },
      {
        name: 'Jump up 4 units (stepped ledge)',
        setup: () => {
          clearGrid();
          // Lower ground - full width
          for (let x = 0; x < GRID_W; x++) setSolid(x, 101);
          // Upper ledge - offset to the right so entity can jump up to it
          for (let x = 70; x < 120; x++) setSolid(x, 97);
          // Start on lower ground, jump up to upper ledge
          return { startX: 68, startY: 100, endX: 80, endY: 96 };
        }
      },
      {
        name: 'Walk on flat ground',
        setup: () => {
          clearGrid();
          for (let x = 0; x < GRID_W; x++) setSolid(x, 101);
          return { startX: 50, startY: 100, endX: 100, endY: 100 };
        }
      },
      {
        name: 'Complex: walk, fall, walk',
        setup: () => {
          clearGrid();
          // Upper platform
          for (let x = 30; x < 60; x++) setSolid(x, 51);
          // Lower platform  
          for (let x = 50; x < 100; x++) setSolid(x, 101);
          // Ground
          for (let x = 0; x < GRID_W; x++) setSolid(x, 121);
          return { startX: 35, startY: 50, endX: 90, endY: 100 };
        }
      },
    ];

    function stopAnimation() {
      if (currentAnimation) {
        cancelAnimationFrame(currentAnimation);
        currentAnimation = null;
      }
    }

    function runAnimatedTest(test, element) {
      stopAnimation();
      clearLog();
      
      log(`Running: ${test.name}`);
      
      const { startX, startY, endX, endY } = test.setup();
      
      log(`Start: (${startX}, ${startY}), End: (${endX}, ${endY})`);
      log(`isWalkable(start): ${isWalkable(startX, startY)}`);
      log(`isWalkable(end): ${isWalkable(endX, endY)}`);
      
      const path = findPath(startX, startY, endX, endY);
      log(`Path found: ${path.length} steps`);
      
      if (path.length === 0) {
        drawGrid();
        drawPoint(startX, startY, '#0f0', 'Start');
        drawPoint(endX, endY, '#f00', 'End');
        element.className = 'test fail';
        element.querySelector('small').textContent = 'No path found';
        return;
      }
      
      const expandedPath = expandPath(path, startX, startY);
      log(`Expanded path: ${expandedPath.length} steps`);
      
      const entity = new AnimatedEntity(startX, startY, '#4f8');
      entity.path = [...expandedPath];
      
      element.className = 'test running';
      element.querySelector('small').textContent = 'Running...';
      
      function animate() {
        drawGrid();
        drawPath(expandedPath, startX, startY);
        drawPoint(startX, startY, 'rgba(0, 255, 0, 0.5)', 'Start');
        drawPoint(endX, endY, 'rgba(255, 100, 100, 0.8)', 'End');
        entity.draw();
        
        const stillMoving = entity.update();
        
        if (stillMoving) {
          currentAnimation = requestAnimationFrame(animate);
        } else {
          // Check if we reached the destination
          const dist = Math.abs(entity.x - endX) + Math.abs(entity.y - endY);
          const nearEnd = findNearestWalkable(endX, endY);
          const distToNearEnd = nearEnd ? Math.abs(entity.x - nearEnd.x) + Math.abs(entity.y - nearEnd.y) : Infinity;
          
          if (dist <= 2 || distToNearEnd <= 2) {
            element.className = 'test pass';
            element.querySelector('small').textContent = `Reached destination in ${expandedPath.length} steps`;
            log('✓ PASSED - Entity reached destination');
          } else {
            element.className = 'test fail';
            element.querySelector('small').textContent = `Stopped at (${entity.x.toFixed(1)}, ${entity.y.toFixed(1)})`;
            log(`✗ FAILED - Entity stopped at (${entity.x}, ${entity.y})`);
          }
          currentAnimation = null;
        }
      }
      
      animate();
    }

    function createTestElement(test, index) {
      const div = document.createElement('div');
      div.className = 'test pending';
      div.innerHTML = `<strong>${test.name}</strong><br><small>Click to run</small>`;
      div.addEventListener('click', () => runAnimatedTest(test, div));
      results.appendChild(div);
      testElements.push({ test, element: div });
      return div;
    }

    async function runAllTests() {
      for (const { test, element } of testElements) {
        await new Promise(resolve => {
          const originalClassName = element.className;
          runAnimatedTest(test, element);
          
          // Wait for animation to complete
          const checkComplete = () => {
            if (!currentAnimation) {
              setTimeout(resolve, 500); // Brief pause between tests
            } else {
              setTimeout(checkComplete, 100);
            }
          };
          checkComplete();
        });
      }
    }

    // Setup
    tests.forEach((test, i) => createTestElement(test, i));
    
    document.getElementById('runAll').addEventListener('click', runAllTests);
    document.getElementById('stopTest').addEventListener('click', stopAnimation);
    
    async function runCaSuite() {
      if (caTestState.status === 'running') return;
      postCaStatus('running');
      await runAllTests();
      const passed = testElements.filter(({ element }) => element.className.includes('pass')).length;
      const failed = testElements.filter(({ element }) => element.className.includes('fail')).length;
      postCaResult(failed === 0, { passed, failed, total: testElements.length });
    }

    window.caTest = {
      run: runCaSuite,
      getStatus: () => ({ ...caTestState }),
    };

    const autorun = new URLSearchParams(window.location.search).get('autorun') === '1';
    if (autorun) {
      runCaSuite();
    }
  </script>
</body>
</html>
