<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Structure Stability Tests</title>
  <style>
    body { font-family: system-ui, sans-serif; background: #1a1a1a; color: #eee; padding: 20px; }
    .test { margin: 10px 0; padding: 10px; border-radius: 6px; cursor: pointer; }
    .test:hover { opacity: 0.8; }
    .pass { background: #1a4a1a; border: 1px solid #2a6a2a; }
    .fail { background: #4a1a1a; border: 1px solid #6a2a2a; }
    .pending { background: #3a3a1a; border: 1px solid #5a5a2a; }
    .running { background: #1a3a4a; border: 1px solid #2a5a6a; }
    canvas { border: 1px solid #444; margin: 10px 0; display: block; }
    pre { background: #222; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 12px; max-height: 200px; overflow-y: auto; }
    h2 { margin-top: 30px; }
    .controls { margin: 10px 0; }
    button { background: #333; color: #eee; border: 1px solid #555; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-right: 8px; }
    button:hover { background: #444; }
    .info { font-size: 12px; opacity: 0.7; margin-top: 5px; }
    .test-name { font-weight: bold; }
    .test-details { font-size: 12px; opacity: 0.8; margin-top: 4px; }
    .summary { padding: 15px; border-radius: 8px; margin: 20px 0; font-size: 18px; }
    .summary.all-pass { background: #1a4a1a; border: 2px solid #2a6a2a; }
    .summary.has-fail { background: #4a1a1a; border: 2px solid #6a2a2a; }
  </style>
</head>
<body>
  <h1>Structure Stability Tests</h1>
  <p class="info">Tests verify that structures remain stable (or collapse as expected) after running physics simulation.</p>
  
  <div class="controls">
    <button id="runAll">Run All Tests</button>
    <button id="stopTest">Stop</button>
    <span id="progress"></span>
  </div>
  
  <div id="summary" class="summary pending">Tests not yet run</div>
  <div id="results"></div>
  
  <h2>Visual Debug</h2>
  <canvas id="debugCanvas" width="640" height="400"></canvas>
  <pre id="log"></pre>

  <!--
    CA test harness:
    - window.caTest.run() / window.caTest.getStatus()
    - postMessage events: ca-test-status, ca-test-result
    - supports ?autorun=1
  -->
  <script>
    const caTestState = {
      name: 'stability',
      status: 'idle',
      passed: null,
      details: null,
    };

    function postCaStatus(status, details = null) {
      caTestState.status = status;
      caTestState.details = details;
      if (window.parent) {
        window.parent.postMessage({
          type: 'ca-test-status',
          name: caTestState.name,
          status,
          details,
        }, '*');
      }
    }

    function postCaResult(passed, details = null) {
      caTestState.status = passed ? 'pass' : 'fail';
      caTestState.passed = passed;
      caTestState.details = details;
      if (window.parent) {
        window.parent.postMessage({
          type: 'ca-test-result',
          name: caTestState.name,
          passed,
          details,
        }, '*');
      }
    }
    const GRID_W = 160;
    const GRID_H = 100;
    const results = document.getElementById('results');
    const logEl = document.getElementById('log');
    const summaryEl = document.getElementById('summary');
    const progressEl = document.getElementById('progress');
    const canvas = document.getElementById('debugCanvas');
    const ctx = canvas.getContext('2d');

    let cpuCells = new Uint32Array(GRID_W * GRID_H);
    let bondsH = new Uint32Array((GRID_W - 1) * GRID_H);
    let bondsV = new Uint32Array(GRID_W * (GRID_H - 1));
    let logText = '';
    let testElements = [];
    let stopRequested = false;

    // Physics constants (must match shaders.wgsl)
    const COHESION_TH = 120;
    const SUPPORT_TH = 40;
    const HORIZONTAL_SUPPORT_RANGE = 6; // How far horizontal support can propagate

    function log(msg) {
      logText += msg + '\n';
      logEl.textContent = logText;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() {
      logText = '';
      logEl.textContent = '';
    }

    function getSolid(cell) {
      const dmg = cell & 0xff;
      const solidBit = (cell >> 8) & 1;
      return solidBit === 1 && dmg < 255;
    }

    function isSupport(cell) {
      return getSolid(cell) && ((cell >> 9) & 1) === 1;
    }

    function setSolid(x, y, passable = false) {
      if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return;
      const p = passable ? (1 << 9) : 0;
      cpuCells[y * GRID_W + x] = (1 << 8) | p;
    }

    function clearGrid() {
      cpuCells.fill(0);
      bondsH.fill(255);
      bondsV.fill(255);
    }

    function idx(x, y) { return y * GRID_W + x; }

    // Get bond strengths
    function bondHAt(x, y) {
      if (x < 0 || x >= GRID_W - 1 || y < 0 || y >= GRID_H) return 0;
      return bondsH[y * (GRID_W - 1) + x] & 0xff;
    }

    function bondVAt(x, y) {
      if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H - 1) return 0;
      return bondsV[y * GRID_W + x] & 0xff;
    }

    // Check if cell has vertical support (solid below with strong bond)
    function hasVerticalSupport(x, y, cells = cpuCells) {
      if (y + 1 >= GRID_H) return true; // Bottom of grid is supported
      if (!getSolid(cells[idx(x, y + 1)])) return false; // Nothing solid below
      return bondVAt(x, y) >= SUPPORT_TH; // Strong enough vertical bond
    }

    // Check if cell is supported (directly or through horizontal bonds)
    function isSupported(x, y, cells = cpuCells) {
      // Direct vertical support
      if (hasVerticalSupport(x, y, cells)) return true;
      
      // Check left for horizontal support chain
      let lx = x;
      for (let i = 0; i < HORIZONTAL_SUPPORT_RANGE; i++) {
        if (lx <= 0) break;
        const bond = bondHAt(lx - 1, y);
        if (bond < COHESION_TH) break; // Chain broken
        lx--;
        if (!getSolid(cells[idx(lx, y)])) break; // No cell to bond to
        if (hasVerticalSupport(lx, y, cells)) return true; // Found support
      }
      
      // Check right for horizontal support chain
      let rx = x;
      for (let i = 0; i < HORIZONTAL_SUPPORT_RANGE; i++) {
        if (rx + 1 >= GRID_W) break;
        const bond = bondHAt(rx, y);
        if (bond < COHESION_TH) break; // Chain broken
        rx++;
        if (!getSolid(cells[idx(rx, y)])) break; // No cell to bond to
        if (hasVerticalSupport(rx, y, cells)) return true; // Found support
      }
      
      return false;
    }

    // Physics simulation (JavaScript version matching WGSL)
    function emptyAt(x, y) {
      if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return true;
      return !getSolid(cpuCells[idx(x, y)]);
    }

    function cohesionOkForFall(x, y) {
      // Left neighbor strongly bonded?
      if (x > 0) {
        const b = bondHAt(x - 1, y);
        if (b >= COHESION_TH && getSolid(cpuCells[idx(x - 1, y)])) {
          if (y + 1 >= GRID_H || !emptyAt(x - 1, y + 1)) return false;
        }
      }
      // Right neighbor strongly bonded?
      if (x + 1 < GRID_W) {
        const b = bondHAt(x, y);
        if (b >= COHESION_TH && getSolid(cpuCells[idx(x + 1, y)])) {
          if (y + 1 >= GRID_H || !emptyAt(x + 1, y + 1)) return false;
        }
      }
      return true;
    }

    function supportAllowsFall(x, y, cells = cpuCells) {
      // Cell is supported if it has direct vertical support OR horizontal support chain
      return !isSupported(x, y, cells);
    }

    // Bond decay: bonds between solid and empty cells weaken over time
    function simulateBondDecay() {
      let decayCount = 0;
      
      // Horizontal bonds
      for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W - 1; x++) {
          const a = cpuCells[idx(x, y)];
          const b = cpuCells[idx(x + 1, y)];
          if (!getSolid(a) || !getSolid(b)) {
            const bi = y * (GRID_W - 1) + x;
            const s = bondsH[bi] & 0xff;
            if (s > 0) {
              bondsH[bi] = Math.max(0, s - 10);
              decayCount++;
            }
          }
        }
      }
      
      // Vertical bonds - bond at (x,y) connects cell (x,y) to cell (x,y+1)
      for (let y = 0; y < GRID_H - 1; y++) {
        for (let x = 0; x < GRID_W; x++) {
          const a = cpuCells[idx(x, y)];
          const b = cpuCells[idx(x, y + 1)];
          if (!getSolid(a) || !getSolid(b)) {
            const bi = y * GRID_W + x;
            const s = bondsV[bi] & 0xff;
            if (s > 0) {
              bondsV[bi] = Math.max(0, s - 10);
              decayCount++;
            }
          }
        }
      }
      
      return decayCount;
    }

    function simulateStep(frame) {
      const newCells = new Uint32Array(cpuCells);
      let moveCount = 0;

      // Helper to check solid in new state
      function solidInNew(x, y) {
        if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return false;
        return getSolid(newCells[idx(x, y)]);
      }

      function emptyInNew(x, y) {
        if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return true;
        return !getSolid(newCells[idx(x, y)]);
      }

      // Cohesion check using current state of newCells
      function cohesionOkNew(x, y) {
        if (x > 0) {
          const b = bondHAt(x - 1, y);
          if (b >= COHESION_TH && solidInNew(x - 1, y)) {
            if (y + 1 >= GRID_H || !emptyInNew(x - 1, y + 1)) return false;
          }
        }
        if (x + 1 < GRID_W) {
          const b = bondHAt(x, y);
          if (b >= COHESION_TH && solidInNew(x + 1, y)) {
            if (y + 1 >= GRID_H || !emptyInNew(x + 1, y + 1)) return false;
          }
        }
        return true;
      }

      // Step pass - process from bottom to top so falling cells don't collide
      for (let y = GRID_H - 2; y >= 0; y--) {
        for (let x = 0; x < GRID_W; x++) {
          const i = idx(x, y);
          const c = newCells[i]; // Check newCells, not cpuCells
          if (!getSolid(c)) continue;

          // Checkerboard
          if (((x + y + (frame & 1)) & 1) !== 0) continue;

          // Try down
          if (y + 1 < GRID_H) {
            const belowI = idx(x, y + 1);
            const belowC = newCells[belowI];
            if (!getSolid(belowC) && supportAllowsFall(x, y, newCells) && cohesionOkNew(x, y)) {
              newCells[belowI] = c;
              newCells[i] = 0;
              moveCount++;
              continue;
            }

            // Diagonals - only if blocked below
            if (getSolid(belowC)) {
              if (x > 0) {
                const dlI = idx(x - 1, y + 1);
                const dlC = newCells[dlI];
                if (!getSolid(dlC)) {
                  const hb = bondHAt(x - 1, y);
                  if (hb < COHESION_TH && supportAllowsFall(x, y, newCells) && cohesionOkNew(x, y)) {
                    newCells[dlI] = c;
                    newCells[i] = 0;
                    moveCount++;
                    continue;
                  }
                }
              }
              if (x + 1 < GRID_W) {
                const drI = idx(x + 1, y + 1);
                const drC = newCells[drI];
                if (!getSolid(drC)) {
                  const hb = bondHAt(x, y);
                  if (hb < COHESION_TH && supportAllowsFall(x, y, newCells) && cohesionOkNew(x, y)) {
                    newCells[drI] = c;
                    newCells[i] = 0;
                    moveCount++;
                    continue;
                  }
                }
              }
            }
          }
        }
      }

      cpuCells.set(newCells);
      return moveCount;
    }

    function simulate(frames) {
      let totalMoves = 0;
      for (let i = 0; i < frames; i++) {
        simulateBondDecay();
        totalMoves += simulateStep(i);
      }
      return totalMoves;
    }

    function drawGrid() {
      const scaleX = canvas.width / GRID_W;
      const scaleY = canvas.height / GRID_H;

      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < GRID_H; y++) {
        for (let x = 0; x < GRID_W; x++) {
          const cell = cpuCells[idx(x, y)];
          if (getSolid(cell)) {
            ctx.fillStyle = isSupport(cell) ? '#5a4a3a' : '#8090a0';
            ctx.fillRect(x * scaleX, y * scaleY, scaleX + 0.5, scaleY + 0.5);
          }
        }
      }
    }

    function countSolidCells() {
      let count = 0;
      for (let i = 0; i < cpuCells.length; i++) {
        if (getSolid(cpuCells[i])) count++;
      }
      return count;
    }

    function countSolidInRect(x0, y0, w, h) {
      let count = 0;
      for (let y = y0; y < y0 + h; y++) {
        for (let x = x0; x < x0 + w; x++) {
          if (x >= 0 && x < GRID_W && y >= 0 && y < GRID_H) {
            if (getSolid(cpuCells[idx(x, y)])) count++;
          }
        }
      }
      return count;
    }

    // Debug: dump region state including bonds
    function dumpRegion(x0, y0, w, h, label) {
      const data = {
        label,
        region: `(${x0},${y0}) ${w}x${h}`,
        cells: [],
        verticalBondIssues: [],
        horizontalBondIssues: []
      };
      
      for (let y = y0; y < y0 + h; y++) {
        for (let x = x0; x < x0 + w; x++) {
          if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) continue;
          
          const cell = cpuCells[idx(x, y)];
          if (!getSolid(cell)) continue;
          
          const vBond = bondVAt(x, y);
          const hBond = bondHAt(x, y);
          const belowSolid = y + 1 < GRID_H ? getSolid(cpuCells[idx(x, y + 1)]) : true;
          const support = isSupport(cell);
          
          // Check for potential issues
          if (!belowSolid && vBond < SUPPORT_TH) {
            data.verticalBondIssues.push({
              pos: `(${x},${y})`,
              vBond,
              belowSolid,
              willFall: true
            });
          }
          
          // Only include a sample of cells
          if (data.cells.length < 20) {
            data.cells.push({
              pos: `(${x},${y})`,
              support,
              vBond,
              hBond,
              belowSolid
            });
          }
        }
      }
      
      return data;
    }

    function getCellsSnapshot() {
      return new Uint32Array(cpuCells);
    }

    function cellsMatch(a, b) {
      for (let i = 0; i < a.length; i++) {
        const solidA = getSolid(a[i]);
        const solidB = getSolid(b[i]);
        if (solidA !== solidB) return false;
      }
      return true;
    }

    // Helper builders
    function rect(x0, y0, w, h, passable = false) {
      for (let y = y0; y < y0 + h; y++) {
        for (let x = x0; x < x0 + w; x++) {
          setSolid(x, y, passable);
        }
      }
    }

    function column(x0, topY, bottomY, w = 2, passable = true) {
      for (let y = topY; y <= bottomY; y++) {
        for (let dx = 0; dx < w; dx++) {
          setSolid(x0 + dx, y, passable);
        }
      }
    }

    // Checkered column - doesn't overwrite existing cells, interleaves with floor
    function checkeredColumn(x0, topY, bottomY, w = 2, passable = true) {
      for (let y = topY; y <= bottomY; y++) {
        for (let dx = 0; dx < w; dx++) {
          // Only set if not already solid (preserves floor continuity)
          const i = idx(x0 + dx, y);
          if (!getSolid(cpuCells[i])) {
            setSolid(x0 + dx, y, passable);
          }
        }
      }
    }

    function floor(x0, y, w, thick = 2) {
      rect(x0, y, w, thick);
    }

    function ground(y) {
      for (let gy = y; gy < GRID_H; gy++) {
        for (let x = 0; x < GRID_W; x++) {
          setSolid(x, gy);
        }
      }
    }

    // ===== TEST DEFINITIONS =====
    const tests = [
      {
        name: "Single floating cell falls",
        description: "A single cell floating in air should fall to ground",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          setSolid(80, 40); // Single floating cell
        },
        frames: 100,
        verify: (before, after) => {
          // Cell should have moved from y=40 to near ground
          const atOriginal = getSolid(after[idx(80, 40)]);
          return !atOriginal;
        }
      },
      {
        name: "4x4 solid block on ground stays intact",
        description: "A 4x4 block resting on ground should not change",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          rect(40, GRID_H - 9, 4, 4);
        },
        frames: 100,
        verify: (before, after) => {
          return cellsMatch(before, after);
        }
      },
      {
        name: "Unsupported 4x4 block falls to ground",
        description: "A 4x4 block floating in air should fall and land on ground",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          rect(80, 40, 4, 4); // Floating high up, centered
        },
        frames: 300,
        verify: (before, after) => {
          // Block should no longer be at original position
          const originalPos = countSolidInRect(80, 40, 4, 4);
          // Should have landed near ground
          const nearGround = countSolidInRect(75, GRID_H - 15, 14, 10);
          return originalPos < 16 || nearGround > 0;
        }
      },
      {
        name: "Small supported beam stays up",
        description: "A 12-wide beam with columns at both ends stays intact (within horizontal support range)",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          const beamY = GRID_H - 20;
          // Beam can span up to 12 cells (6 from each side)
          floor(40, beamY, 12, 2);
          column(40, beamY, GRID_H - 6, 2, true);
          column(50, beamY, GRID_H - 6, 2, true);
        },
        frames: 100,
        verify: (before, after) => {
          return cellsMatch(before, after);
        }
      },
      {
        name: "Wide unsupported beam collapses in middle",
        description: "A 40-wide beam with only end supports will sag/collapse",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          const beamY = GRID_H - 20;
          floor(40, beamY, 40, 2);
          column(40, beamY, GRID_H - 6, 2, true);
          column(78, beamY, GRID_H - 6, 2, true);
        },
        frames: 200,
        verify: (before, after) => {
          // Structure should have changed
          return !cellsMatch(before, after);
        }
      },
      {
        name: "Beam with adequate supports stays up",
        description: "A 40-wide beam with supports every 10 cells stays intact",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          const beamY = GRID_H - 20;
          floor(40, beamY, 40, 2);
          // Supports every 10 cells - within range of 6 from each side
          column(40, beamY, GRID_H - 6, 2, true);
          column(50, beamY, GRID_H - 6, 2, true);
          column(60, beamY, GRID_H - 6, 2, true);
          column(70, beamY, GRID_H - 6, 2, true);
          column(78, beamY, GRID_H - 6, 2, true);
        },
        frames: 100,
        verify: (before, after) => {
          return cellsMatch(before, after);
        }
      },
      {
        name: "Tower with internal supports stays up",
        description: "3-story tower with support columns remains stable",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          const groundY = GRID_H - 5;
          const towerX = 50;
          const towerW = 30;
          const floorH = 12;
          const roofY = groundY - 1 - 3 * floorH;
          const wallHeight = groundY - roofY; // Extend walls all the way to ground
          
          // 3 floors - laid FIRST to ensure continuous horizontal bonds
          for (let f = 0; f < 3; f++) {
            const fy = groundY - 1 - (f + 1) * floorH;
            floor(towerX, fy + floorH - 2, towerW, 2); // Floor first
          }
          floor(towerX, roofY, towerW, 2); // Roof
          
          // Walls from roof to ground (full height)
          rect(towerX, roofY, 2, wallHeight); // Left wall
          rect(towerX + towerW - 2, roofY, 2, wallHeight); // Right wall
          
          // Support columns using checkered pattern - from roof to ground
          // Doesn't overwrite floor cells, so horizontal bonds remain intact
          checkeredColumn(towerX + 8, roofY, groundY - 1, 2, true);
          checkeredColumn(towerX + 15, roofY, groundY - 1, 2, true);
          checkeredColumn(towerX + 22, roofY, groundY - 1, 2, true);
        },
        frames: 150,
        verify: (before, after) => {
          return cellsMatch(before, after);
        }
      },
      {
        name: "Tower without supports collapses",
        description: "Same tower but without support columns should collapse",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          const baseY = GRID_H - 6;
          const towerX = 60;
          const towerW = 30;
          const floorH = 15;
          
          // 3 floors with walls only (no internal supports)
          for (let f = 0; f < 3; f++) {
            const fy = baseY - (f + 1) * floorH;
            rect(towerX, fy, 2, floorH);
            rect(towerX + towerW - 2, fy, 2, floorH);
            floor(towerX, fy + floorH - 2, towerW, 2);
          }
          floor(towerX, baseY - 3 * floorH, towerW, 2);
        },
        frames: 200,
        verify: (before, after) => {
          // Structure should have changed (collapsed)
          return !cellsMatch(before, after);
        }
      },
      {
        name: "Cantilever limited overhang stays up",
        description: "Cantilever (5 cells) from wall stays stable due to horizontal support propagation",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          // Thick wall that goes all the way down
          rect(40, GRID_H - 30, 4, 25);
          // Cantilever up to 5 cells (within support range of 6)
          floor(44, GRID_H - 20, 5, 2);
        },
        frames: 100,
        verify: (before, after) => {
          return cellsMatch(before, after);
        }
      },
      {
        name: "Long cantilever collapses",
        description: "Long cantilever (20 cells) from wall will fall",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          // Thick wall
          rect(40, GRID_H - 30, 4, 25);
          // Long cantilever
          floor(44, GRID_H - 20, 20, 2);
        },
        frames: 200,
        verify: (before, after) => {
          // Structure should have changed
          return !cellsMatch(before, after);
        }
      },
      {
        name: "Bridge with supports stays up",
        description: "Bridge with supports every 10 cells remains stable",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          const bridgeY = GRID_H - 25;
          const bridgeW = 50;
          const startX = 40;
          
          floor(startX, bridgeY, bridgeW, 2);
          
          // Supports every 10 cells - within horizontal support range
          for (let x = startX; x < startX + bridgeW; x += 10) {
            column(x, bridgeY, GRID_H - 6, 2, true);
          }
          column(startX + bridgeW - 2, bridgeY, GRID_H - 6, 2, true);
        },
        frames: 100,
        verify: (before, after) => {
          return cellsMatch(before, after);
        }
      },
      {
        name: "Single cell on ground is stable",
        description: "Edge case: single cell should not disappear",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          setSolid(80, GRID_H - 6);
        },
        frames: 50,
        verify: (before, after) => {
          return getSolid(after[idx(80, GRID_H - 6)]);
        }
      },
      {
        name: "Vertical stack is stable",
        description: "A 1-wide vertical column should remain intact",
        setup: () => {
          clearGrid();
          ground(GRID_H - 5);
          for (let y = GRID_H - 25; y < GRID_H - 5; y++) {
            setSolid(80, y);
          }
        },
        frames: 100,
        verify: (before, after) => {
          return cellsMatch(before, after);
        }
      },
    ];

    // ===== TEST RUNNER =====
    function createTestElement(test, index) {
      const div = document.createElement('div');
      div.className = 'test pending';
      div.innerHTML = `
        <div class="test-name">${index + 1}. ${test.name}</div>
        <div class="test-details">${test.description}</div>
      `;
      div.onclick = () => runSingleTest(index, true);
      results.appendChild(div);
      return div;
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function runSingleTest(index, animate = false) {
      const test = tests[index];
      const el = testElements[index];
      
      clearLog();
      log(`Running: ${test.name}`);
      log(test.description);
      log('');
      
      el.className = 'test running';
      
      // Setup
      test.setup();
      const before = getCellsSnapshot();
      const initialCount = countSolidCells();
      log(`Initial solid cells: ${initialCount}`);
      
      if (animate) {
        drawGrid();
        await sleep(500);
      }

      // Run simulation
      let totalMoves = 0;
      if (animate) {
        for (let f = 0; f < test.frames && !stopRequested; f++) {
          simulateBondDecay();
          totalMoves += simulateStep(f);
          if (f % 5 === 0) {
            drawGrid();
            await sleep(16);
          }
        }
      } else {
        totalMoves = simulate(test.frames);
      }

      const after = getCellsSnapshot();
      const finalCount = countSolidCells();
      log(`Final solid cells: ${finalCount}`);
      log(`Total cell moves: ${totalMoves}`);
      log(`Frames simulated: ${test.frames}`);

      // Verify
      const passed = test.verify(before, after);
      el.className = passed ? 'test pass' : 'test fail';
      el.innerHTML = `
        <div class="test-name">${passed ? '✓' : '✗'} ${index + 1}. ${test.name}</div>
        <div class="test-details">${test.description} (${test.frames} frames, ${initialCount}→${finalCount} cells)</div>
      `;

      log(passed ? '✓ PASSED' : '✗ FAILED');
      
      // Debug output for failed tests
      if (!passed) {
        const debugInfo = {
          testName: test.name,
          frames: test.frames,
          initialCells: initialCount,
          finalCells: finalCount,
          totalMoves: totalMoves,
          changed: !cellsMatch(before, after),
        };
        
        // Sample some bond values for supported structures
        if (test.name.includes('support') || test.name.includes('Support') || 
            test.name.includes('Cantilever') || test.name.includes('Bridge')) {
          // Find some solid cells and check their bonds
          const sampleBonds = [];
          let samplesFound = 0;
          for (let y = 0; y < GRID_H && samplesFound < 10; y++) {
            for (let x = 0; x < GRID_W && samplesFound < 10; x++) {
              if (getSolid(cpuCells[idx(x, y)])) {
                const vBond = bondVAt(x, y);
                const hBond = bondHAt(x, y);
                const belowSolid = y + 1 < GRID_H ? getSolid(cpuCells[idx(x, y + 1)]) : false;
                sampleBonds.push({
                  pos: `(${x},${y})`,
                  vBond,
                  hBond,
                  belowSolid,
                  isSupport: isSupport(cpuCells[idx(x, y)])
                });
                samplesFound++;
              }
            }
          }
          debugInfo.sampleBonds = sampleBonds;
        }
        
        console.log('DEBUG TEST FAILURE:', JSON.stringify(debugInfo, null, 2));
      }

      if (animate) {
        drawGrid();
      }

      return passed;
    }

    async function runAllTests() {
      stopRequested = false;
      let passed = 0;
      let failed = 0;

      for (let i = 0; i < tests.length && !stopRequested; i++) {
        progressEl.textContent = `Running ${i + 1}/${tests.length}...`;
        const result = await runSingleTest(i, false);
        if (result) passed++; else failed++;
        await sleep(10); // Let UI update
      }

      progressEl.textContent = '';
      summaryEl.textContent = `${passed} passed, ${failed} failed out of ${tests.length} tests`;
      summaryEl.className = failed === 0 ? 'summary all-pass' : 'summary has-fail';
      
      // Draw final state of last test
      drawGrid();
      return { passed, failed, total: tests.length };
    }

    // Initialize
    tests.forEach((test, i) => {
      testElements.push(createTestElement(test, i));
    });

    document.getElementById('runAll').onclick = runAllTests;
    document.getElementById('stopTest').onclick = () => { stopRequested = true; };

    async function runCaSuite() {
      if (caTestState.status === 'running') return;
      postCaStatus('running');
      const summary = await runAllTests();
      postCaResult(summary.failed === 0, summary);
    }

    window.caTest = {
      run: runCaSuite,
      getStatus: () => ({ ...caTestState }),
    };

    const autorun = new URLSearchParams(window.location.search).get('autorun') === '1';
    if (autorun) {
      runCaSuite();
    }

    // Draw empty grid initially
    clearGrid();
    ground(GRID_H - 5);
    drawGrid();
  </script>
</body>
</html>
